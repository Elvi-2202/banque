Justificatif de choix de modelisation
Introduction :
Dans le cadre de ce projet, l’objectif est de concevoir une base de donnees permettant de gerer un système bancaire integrant : 
	La gestion des clients 
	Les comptes bancaires
	Les transactions et operations 
	La securite (fraude ,audit)
	L’historique
 
Analyse :
	Les contraintes fournies :
		Un client peut avoir plusieurs comptes
		Un compte appartient à un seul client
		Solde non negatif
		Historisation obligatoire
Interdiction de debit si solde insuffisant
 
Choix de modelisation :
•	Table CLIENT :
	La table CLIENT centralise les informations client
		 id_client : identifiant unique du client (cle primaire)
  		nom : nom du client
prenom : prenom du client
email : adresse email (unique)
date_naissance : date de naissance
dt_entrer_relation : date d’entree en relation avec la banque
		mdp : mot de passe securise
dt_crea : date de creation du compte
dt_modif : date de dernière modification
 
•	Table COMPTE_BANCAIRE :
	La table  COMPTE_BANCAIRE  presente tout les comptes des clients
		  id_compte : identifiant unique du compte (cle primaire)
type : type de compte (COURANT, EPARGNE)
  numero_compte : numero unique du compte
  solde : montant disponible (≥ 0)
  devise : devise du compte (par defaut EUR)
  statut : etat du compte (actif, suspendu…)
  dt_crea : date de creation
  dt_modif : date de modification
  id_client : reference au client (cle etrangère)
 
•	Table TRANSACTION_BANCAIRE 
La table TRANSACTION_BANCAIRE permet d’enregistrer toutes les transactions financières 
id_transaction : identifiant unique
  montant : montant de la transaction
  dt_crea : date et heure de la transaction
  description : detail de la transaction
  id_compte_bancaire : compte concerne (cle etrangère)
  type : type (VIREMENT, DEPOT, RETRAIT)
 
•	Table TYPE_OPERATION
	La table TYPE_OPERATION est une table de reference des types d’operations
  id_type : identifiant unique
  libelle : nom du type d’operation (unique)
 
•	Table OPERATION
	La table OPERATION represente une operation metier liee à une transaction
  id_operation : identifiant unique
  montant : montant (> 0)
  statut : (EN_ATTENTE, VALIDE, REFUSE)
  dt_exec : date d’execution
  ref_destinataire : reference du beneficiaire
  description : detail
  id_transaction_bancaire : reference transaction (cle etrangère)
  id_type_operation : type d’operation (cle etrangère)
•	Table BENEFICIAIRE
  	La table BENEFICIAIRE stocke les destinataires des virements
  id_beneficiaire : identifiant unique
  iban : IBAN (unique)
  nom : nom du beneficiaire
  dt_crea : date de creation
  id_client : client proprietaire (cle etrangère)
•	Table CARTE_BANCAIRE 
	La table CARTE_BANCAIRE represente les cartes associees aux comptes
  id_carte : identifiant unique
  numero_carte : numero de carte (unique)
  dt_expiration : date d’expiration
  cvc : code de securite
  plafond_paiement : limite de paiement
  statut : (ACTIVE, BLOQUEE, EXPIREE)
  id_compte_bancaire : compte lie (unique, cle etrangère)
 
•	Table SYSTEME
	La table SYSTEME represente les utilisateurs internes
  id_systeme : identifiant unique
  email : email (unique)
  password : mot de passe
  role : (ADMIN, ANALYSTE, SUPPORT)
  dt_crea : date de creation
 
•	Table ALERTE_FRAUDE
	La table ALERTE_FRAUDE permet de detecter et suivre les fraudes
  id_alerte_fraude : identifiant unique
  type : type d’alerte
  statut : (EN_COURS, TRAITEE, FAUSSE_ALERTE)
  dt_alerte : date de detection
  dt_resolu : date de resolution
  id_transaction : transaction concernee (cle etrangère)
  id_systeme : agent ayant traite (cle etrangère
•	Table AUDIT_LOGS
	La table AUDIT_LOGS trace toutes les actions du système
  id_audit : identifiant unique
  id_client : client concerne
  id_systeme : utilisateur interne
  id_compte : compte concerne
  id_transaction : transaction concernee
  action_effectuee : action realisee
  dt_action : date
  ip_address : adresse IP
  details_technique : informations techniques
Conclusion : 
Le choix de modelisation repose sur :
•	Une normalisation des donnees
•	Une prise en compte des contraintes metier
•	Une forte traçabilite et securite
 
Tests et manipulation des requêtes SQL
 
avant index
EXPLAIN ANALYZE 
SELECT * FROM compte_bancaire WHERE solde > 5000;
 
result: EXPLAIN
Filter: (compte_bancaire.solde > 5000.00) (cost=0.75 rows=1.67) 
(actual time=0.0112..0.0128 rows=2 loops=1)Table scan on compte_bancaire 
(cost=0.75 rows=5) (actual time=0.00607..0.00764 rows=5 loops=1)
 
apres index
CREATE INDEX idx_compte_solde ON compte_bancaire(solde);
 
EXPLAIN ANALYZE 
SELECT * FROM compte_bancaire WHERE solde > 5000;
 
result: EXPLAIN
Index range scan on compte_bancaire using idx_compte_solde over (5000.00 < solde), 
with index condition: (compte_bancaire.solde > 5000.00) (cost=1.16 rows=2) 
(actual time=0.0401..0.0422 rows=2 loops=1)
 
Avant index :
MySQL fait un table scan: il lit toutes les lignes de la table compte_bancaire (5 lignes).
Il filtre ensuite celles où solde > 5000.
 
Apres index (idx_compte_solde) :
MySQL fait un index range scan.
Il va directement chercher les lignes où solde > 5000 grâce à un index.
Il ne parcourt plus toute la table, seulement les valeurs utiles.
 
Justifier les Choix:Expliquer pourquoi chaque index a ete cree et sur quelles colonnes.
 
idx_client_email: il permet de verifier instantanement si le mail existe sans scanner toute la liste des clients.
 
idx_compte_solde:il permet de trier les montants tres rapidement.
 
idx_transac_date: il evite de fouiller dans des annees archives pour trouver les operations recentes.
 